// Copyright Jetstack Ltd. See LICENSE for details.
package context

import (
	"net/http"

	"github.com/sebest/xff"
	"k8s.io/apiserver/pkg/authentication/user"
	"k8s.io/apiserver/pkg/endpoints/request"
	"k8s.io/client-go/transport"

	genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
)

type key int

const (
	// noImpersonationKey is the context key for whether to use impersonation.
	noImpersonationKey key = iota

	// impersonationConfigKey is the context key for the impersonation config.
	impersonationConfigKey

	// bearerTokenKey is the context key for the bearer token.
	bearerTokenKey

	// bearerTokenKey is the context key for the client address.
	clientAddressKey
)

type ImpersonationRequest struct {
	ImpersonationConfig *transport.ImpersonationConfig
	InboundUser         *user.Info
	ImpersonatedUser    *user.Info
}

// WithNoImpersonation returns a copy of the request in which the noImpersonation context value is set.
func WithNoImpersonation(req *http.Request) *http.Request {
	return req.WithContext(request.WithValue(req.Context(), noImpersonationKey, true))
}

// NoImpersonation returns whether the noImpersonation context key has been set
func NoImpersonation(req *http.Request) bool {
	noImp, _ := req.Context().Value(noImpersonationKey).(bool)
	return noImp
}

// WithImpersonationConfig returns a copy of parent in which contains the impersonation configuration.
func WithImpersonationConfig(req *http.Request, conf *ImpersonationRequest) *http.Request {
	ctxToReturn := request.WithValue(req.Context(), impersonationConfigKey, conf)
	if *conf.ImpersonatedUser != nil {
		ctxToReturn = genericapirequest.WithUser(ctxToReturn, *conf.ImpersonatedUser)
	}
	return req.WithContext(ctxToReturn)
}

// ImpersonationConfig returns the impersonation configuration held in the context if existing.
func ImpersonationConfig(req *http.Request) *ImpersonationRequest {
	conf, _ := req.Context().Value(impersonationConfigKey).(*ImpersonationRequest)
	return conf
}

// WithBearerToken will add the bearer token to the request context from an http.Header to the request context.
func WithBearerToken(req *http.Request, header http.Header) *http.Request {
	return req.WithContext(request.WithValue(req.Context(), bearerTokenKey, header.Get("Authorization")))
}

// BearerToken will return the bearer token stored in the request context.
func BearerToken(req *http.Request) string {
	token, _ := req.Context().Value(bearerTokenKey).(string)
	return token
}

// RemoteAddress will attempt to return the source client address if available
// in the request context. If it is not, it will be gathered from the request
// and entered into the context.
func RemoteAddr(req *http.Request) (*http.Request, string) {
	ctx := req.Context()

	clientAddress, ok := ctx.Value(clientAddressKey).(string)
	if !ok {
		clientAddress = xff.GetRemoteAddr(req)
		req = req.WithContext(request.WithValue(ctx, clientAddressKey, clientAddress))
	}

	return req, clientAddress
}
